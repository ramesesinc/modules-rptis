import com.rameses.common.*
import com.rameses.annotations.*
import com.rameses.services.extended.*

class TDOnlineService {
	@Env 
	def env

	@Service('DateService')
	def dtSvc

	@Service('RPTBillingService')
	def billSvc

	@Service('RPTUtil')
	def util

	@DataContext('faas')
	def em_faas

	@DataContext('faas_list')
	def em_faaslist

	@DataContext('realproperty')
	def em_realproperty

	@DataContext('rptledger')
	def em_rptledger

	@DataContext('rptpayment')
	def em_rptpayment

	@ActiveDB('rptis_online_taxdec')
	def em_online_taxdec

	@ProxyMethod
	public def verifyTaxDec(params) {
		params.tdno = params.refno 
		def faas = em_faaslist.find([tdno: params.tdno]).first()
		if (!faas) throw new Exception('TD No. does not exist.')

		def rptledger = getLedger(params)
		
		def info = [:]
		info.boundary = getFaasBoundary(faas)
		info.bill = getBill(rptledger)
		info.lastpayment = getLastPayment(rptledger)
		buildFaasInfo(faas, info)
		return info
	}

	/*============================================
	* Validate requested FAAS as follows:
	* - Current only
	* - Fully Paid up to current qtr
	* - Exemptions: 
	*      - Zero Value
	*      - Exempt Properties
	============================================*/
	@ProxyMethod
	public def verifyTaxDecForTxn(params) {
		params.tdno = params.refno 
		def faas = em_faaslist.find([tdno: params.tdno]).first()
		if (!faas) throw new Exception('TD No. does not exist.')

		if ('CANCELLED'.equalsIgnoreCase(faas.state)) {
			throw new Exception('FAAS is already cancelled.')
		}

		if ( ! 'CURRENT'.equalsIgnoreCase(faas.state)) {
			throw new Exception("FAAS is currently verified for approval by the Assessor's Office.")
		}

		def rptledger = getLedgerForTxn(faas)

		def info = [:]
		info.boundary = getFaasBoundary(faas)
		info.bill = getBill(rptledger)
		info.lastpayment = getLastPayment(rptledger)
		buildFaasInfo(faas, info)
		return info
	}

	@ProxyMethod
	public def getImprovementsByPermitNo(params) {
		if (!params.permitno) throw new Exception('Building Permit No. must be specified.')
		return em_online_taxdec.getImprovementsByPermitNo(params);
	}


	def getLedger(params) {
		def rptledger = em_rptledger
						.select('objid,state,tdno,lastyearpaid,lastqtrpaid')
						.find([tdno: params.tdno])
						.first()
		if (!rptledger) {
			rptledger = [tdno: params.tdno]
		}
		return rptledger

	}

	def getLedgerForTxn(faas) {
		def fields = 'objid,state,tdno,lastyearpaid,lastqtrpaid,taxable,totalav'
		def rptledger = em_rptledger.select(fields).find([faasid: faas.objid]).first()
		if (!rptledger) {
			rptledger = em_rptledger.select(fields).find([tdno: faas.tdno]).first()
		}

		def msg = ''
		if (!rptledger || !rptledger.state.toLowerCase().matches('approved|pending')) {
			msg = 'The associated ledger for this FAAS is currently not available.\n'
			msg += 'Kindly ask assistance with the Land Tax Office.'
			throw new Exception(msg)
		}

		if ('PENDING'.equalsIgnoreCase(rptledger.state)) {
			msg = 'The associated ledger for this FAAS is currently verified for approval.\n'
			msg += 'Kindly ask assistance with the Land Tax Office.'
			throw new Exception(msg)
		}

		//verify special case
		if (rptledger.totalav <= 0 || util.toBoolean(rptledger.taxable, true) == false ) {
			return rptledger
		}

		//verify full payment
		def pdate = dtSvc.parseCurrentDate()
		if ((rptledger.lastyearpaid < pdate.year) || 
		    (rptledger.lastyearpaid == pdate.year && rptledger.lastqtrpaid < pdate.qtr)) {
				throw new Exception('The associated ledger for this FAAS is not fully paid.')
		}

		return rptledger

	}

	def getBill(rptledger) {
		def bill = [
			lastyearpaid: rptledger.lastyearpaid, 
	        lastqtrpaid: rptledger.lastqtrpaid,
	        period: '',
			amtdue: 0.0,
		]

		try {
			def b = billSvc.generateBillByTdNo(rptledger)
			bill.amtdue = b.totals.total 
			bill.period = buildPeriodCovered(b.ledgers[0])
		} catch(e) {
			println '[ERROR] ' + e.message
		}
		return bill
	}

	def buildPeriodCovered(rptledger) {
		def items = [
			[	
				fromyear: rptledger.fromyear, 
				fromqtr: rptledger.fromqtr,
				toyear: rptledger.toyear,
				toqtr: rptledger.toqtr, 
			]
		]
		util.buildPeriodCovered(items)
		return items.first().period.toUpperCase().replace('FULL', '') 
	}

	def getLastPayment(rptledger) {
		def pmt = em_rptpayment
					.select('receiptno,receiptdate,amount,paidby_name,paidby_address')
					.where('refid = :objid and voided = 0', rptledger)
					.orderBy('receiptdate desc')
					.first()

		if (!pmt) pmt = [:]
		return pmt 
	}

	def getFaasBoundary(faas) {
		def rp = em_realproperty.find([objid: faas.realpropertyid]).first()
		return [
			north : rp?.north,
			east : rp?.east,
			south : rp?.south,
			west : rp?.west,
			street: rp?.street,
		]
	}

	void buildFaasInfo(faas, info) {
		info.objid = faas.objid
        info.tdno = faas.tdno
        info.pin = faas.displaypin
        info.titleno = faas.titleno
        info.cadastrallotno = faas.cadastrallotno
        info.blockno = faas.blockno
        info.surveyno = faas.surveyno
        info.classcode = faas.classcode
        info.owner = faas.owner
        info.taxpayer = faas.taxpayer
        info.administrator = faas.administrator
        info.barangay = faas.barangay
        info.street = info.boundary.street
        info.areaha = faas.totalareaha
        info.areasqm = faas.totalareasqm
        info.totalmv = faas.totalmv
        info.totalav = faas.totalav
	}

}
