import com.rameses.annotations.*
import com.rameses.common.*;
import com.rameses.services.extended.*;

class RPTMainSyncService {
	@Env 
	def env 

	@Context 
	def appCtx

	@Service()
	def self 

	@Service(value='SyncCoordinatorService', connection='coordinator-script-service')
    def coordinator 

    @Service('DateService')
    def dtSvc 

    @Service('Var')
    def var

    @Service('RPTUtil')
    def util

	@DataContext('syncdata')
	def em_sync

	@DataContext('syncdata_forsync')
	def em_forsync

	@DataContext('syncdata_item')
	def em_sync_item

	@DataContext('syncdata_forprocess')
	def em_sync_forprocess

	@DataContext('syncdata_pending')
	def em_sync_pending

	@DataContext('syncdata_offline_org')
	def em_sync_offline_org

	@DataContext('sys_org')
	def em_org


	@ProxyMethod
	public void updateCompletedSyncData() {
		def syncdatalist = em_sync.select('objid,refno,action').find([state: 'SYNCHING']).orderBy('dtfiled').list()
		syncdatalist.each {
			if (checkSyncCompleted(it)) {
				em_sync.find([objid: it.objid]).update([state: 'COMPLETED'])
				println 'Sync [COMPLETED] ' + it.action + ': ' + it.refno
			}
		}
	}

	@ProxyMethod
	public void deleteCompletedSyncData() {
		def syncdatalist = em_sync.select('objid').find([state: 'COMPLETED']).orderBy('dtfiled').list()
		syncdatalist.each {syncdata ->
			deleteSyncData(syncdata)
		}
	}

	@ProxyMethod
	public void sendData(syncdata){
		try {
			syncdata.state = 'SYNCHING'
			em_sync.find([objid: syncdata.objid]).update([state: syncdata.state])

			def items = getItemsForSync(syncdata)
			items.each { item ->
				try {
					mergeSyncDataInfo(item, syncdata)
					if (util.isTrue(item.async)) {
						self.sendSyncData(item)
						println 'Sync [Async-SENT] ' + item.action + ': ' + item.refno
					} else if (isDependedActionCompleted(item)) {
						self.asyncSend(item)
						logItemSent(item)
						println 'Sync [SENT] ' + item.action + ': ' + item.refno
					}
				} catch (err) {
					logItemError(item, err)
				}
			}
		}
		catch(err){
			moveToPending(syncdata, err)
		}
	}

	def isDependedActionCompleted(item) {
		if (!item.dependedaction) return true

		def param = [
			parentid: item.parentid, 
			action: item.dependedaction,
			sync: 'SYNC'
		]

		def dependeditem = em_sync_item.select('objid')
							.where('parentid = :parentid AND action = :action AND state <> :sync', param)
							.first()

		return dependeditem == null 

	}

	void mergeSyncDataInfo(item, syncdata) {
		item.dtfiled = syncdata.dtfiled
		item.orgid = syncdata.orgid
		item.remote = syncdata.remote
		item.sender = syncdata.sender
		item.fileid = syncdata.fileid
		if (item.info == null) item.info = [:]
		if (syncdata.info) item.info.putAll(syncdata.info)
	}


	@Async
	@ProxyMethod
	public void sendSyncData(syncdata) {
		try {
			self.asyncSend(syncdata)
			logItemSent(syncdata)
		} catch (err) {
			logItemError(syncdata, err)
			moveToPending(syncdata, err)
		}
	}


	/*-------------------------------------
	*
	* Intercepted by implementors to build 
	* the actual data to send to remote 
	*
	--------------------------------------*/
	@ProxyMethod
	public def asyncSend(syncdata){
		return syncdata
	}

	/*-------------------------------------
	*
	* directly send data to coordinator
	*
	--------------------------------------*/
	@ProxyMethod
	public def send(syncdata){
		return coordinator.send(syncdata)
	}

	@ProxyMethod
	public def send2(syncdata, data){
		if (data) {
			syncdata.data = data 
			return coordinator.send(syncdata)	
		}
		return null 
	}


	@ProxyMethod
	public def receiveData(syncdata) {
		def retval = [:]
		def sdata = em_sync_item.select('state').find([objid: syncdata.objid]).first()
		if (sdata && ! 'SYNC'.equalsIgnoreCase(sdata.state)) {
			retval = self.receive(syncdata)
			em_sync_item.find([objid: syncdata.objid]).update([state: 'SYNC'])
			cleanupFullySyncData(syncdata)
		} else {
			retval = self.receive(syncdata)
		}
		println 'Sync [RECEIVED] ' + syncdata.action + ': ' + syncdata.refno 
		return retval
	}

	/*-------------------------------------
	*
	* to be intercepted by receivers
	* use args[0] to access actual data
	--------------------------------------*/
	@ProxyMethod
	public def receive(syncdata){
		//intercepted to return specific data 
		em_sync_item.find([objid: syncdata.objid]).update([state: 'SYNC'])
		return [:]
	}


	@ProxyMethod
	public def createDataForSync(data) {
		data.createdby = [objid: env.USERID, name: env.USER, title: env.JOBTITLE]
		data.dtfiled = dtSvc.serverDate
		em_forsync.create(data)
		return data
	}

	//intercepted to post transaction data to sync
	@ProxyMethod
	public def scheduleSync(data) {
		return data
	}

	@ProxyMethod
	public void deleteDataForSync(data) {
		em_forsync.find([objid: data.objid]).delete()
	}

	@ProxyMethod
	public def create(data) {
		def syncdata = [:]
		syncdata.objid = 'SYNC' + new java.rmi.server.UID()
        syncdata.state = 'PENDING'
        syncdata.refid = data.objid
        syncdata.reftype = data.reftype
        syncdata.refno = data.refno
		syncdata.action = data.action
		syncdata.dtfiled = data.dtfiled
		syncdata.orgid = data.orgid
		syncdata.sender = data.createdby
		syncdata.remote = data.remote
		syncdata.async = false
		if (!syncdata.info) syncdata.info = [:]
		if (data.info) syncdata.info += data.info
        syncdata.idx = 0
		em_sync.create(syncdata)
        return syncdata
	}

	@ProxyMethod
	public def createItem(syncdata, item) {
		item.parentid = syncdata.objid
		item.state = 'PENDING'
		item.idx = (++syncdata.idx)
		em_sync_item.create(item)
		return item
	}

	@ProxyMethod
	public def createSyncMeta(syncdata) {
		def existingData = em_sync.find([objid: syncdata.objid]).first()
		if (!existingData) {
			existingData = em_sync.create(syncdata)
			syncdata.items.each {
				em_sync_item.create(it)
			}
			println 'Sync [META] Receiving ' + syncdata.action + ': '  + syncdata.refno
		}
		return existingData
	}




	@ProxyMethod
	public void schedulePendingData() {
		getPendingSyncData().each {data ->
			sendSyncDataMeta(data)
		}
	}

	@ProxyMethod
	public def getDataForSync(){
		def params = [orgid: getOrgId(), forsync: 'FORSYNC', synching: 'SYNCHING']
		def where = []
		where << 'orgid = :orgid'
		where << '(state = :forsync OR state = :synching)' 
		where << 'pending.objid IS NULL'
		where << 'offline.orgid IS NULL'
		return em_sync.where(where.join(' AND '), params)
				.orderBy('dtfiled')
				.limit(10)
				.list()
	}

	@ProxyMethod
	public def getItemsForSync(syncdata){
		def params = [parentid: syncdata.objid, sync: 'SYNC']
		return em_sync_item.where('parentid = :parentid AND state <> :sync', params)
				.orderBy('idx')
				.limit(50)
				.list()
	}

	

	@ProxyMethod
	public def getForProcessItems(){
		return em_sync.where('forprocess.objid is not null')
				.orderBy('dtfiled, idx')
				.limit(25)
				.list()
	}

	@ProxyMethod
	public def getPendingItems(syncdata){
		def filter = 'pending.objid is not null'

		if (syncdata.orgid) {
			filter = 'orgid = :orgid and pending.objid is not null'
		}

		return em_sync.where(filter, syncdata)
				.orderBy('dtfiled')
				.limit(25)
				.list()
	}

	@ProxyMethod
	public void reschedulePendingData(){
		def where = []
		where << 'pending.objid IS NOT NULL'
		where << 'pending.expirydate <= :currdate'
		where << 'offline.orgid IS NULL'
		def pendings = em_sync.where(where.join(' AND '), [currdate: dtSvc.serverDate])
				.orderBy('dtfiled')
				.limit(25)
				.list()

		pendings.each {
			def pendingitem = em_sync_item.select('objid').find([parentid: it.objid, state: 'PENDING']).first()
			if (pendingitem) {
				sendSyncDataMeta(it)
			} else {
				em_sync.find([objid: it.objid]).update([state: 'FORSYNC'])

				em_sync_item.where('parentid = :parentid AND state <> :sync', [parentid: it.objid, sync: 'SYNC'])
							.update([state: 'FORSYNC'])

				em_sync_pending.delete(it)
			}
		}
	}

	@ProxyMethod
	public void rescheduleOfflineOrg() {
		em_sync_offline_org.where('expirydate < :currdate', [currdate: dtSvc.serverDate]).delete()
	}

	void sendSyncDataMeta(data) {
		try {
			data.items = em_sync_item.find([parentid: data.objid]).list()
			coordinator.createSyncMeta(data)
			em_sync.find([objid: data.objid]).update([state: 'FORSYNC'])
			em_sync_item.find([parentid: data.objid]).update([state: 'FORSYNC'])
			data.items.each {item ->
				em_sync_forprocess.create([objid: item.objid, parentid: data.objid])
			}
			println 'Sync [META] Sending ' + data.action + ': '  + data.refno
		} catch(err) {
			moveToPending(data, err)
		}
	}

	void logItemSent(item){
		em_sync_forprocess.delete(item)
		em_sync_item.find([objid: item.objid]).update([state: 'SYNC', error: null])
	}

	void logItemError(item, err) {
		em_sync_item.find([objid: item.objid]).update([state: 'ERROR', error: err.message])
	}

	void moveToPending(syncdata, err) {
		def currdate = dtSvc.serverDate

		syncdata.error = err.message 
		syncdata.expirydate = dtSvc.add(currdate, '10s')
		em_sync_pending.save(syncdata)
		em_sync.find([objid: syncdata.objid]).update([state: 'ERROR'])

		if (err.message.toLowerCase().matches('.*partner.*')) {
			def offlineorg = em_sync_offline_org.read(syncdata.remote)
			if (!offlineorg) {
				offlineorg = [orgid: syncdata.remote.orgid]
				offlineorg.expirydate = dtSvc.add(currdate, '60s')
				em_sync_offline_org.create(offlineorg)
			}
		}
	}

	def getPendingSyncData(){
		def params = [orgid: getOrgId(), state: 'PENDING']
		return em_sync.where('orgid = :orgid AND state = :state AND pending.objid IS NULL ', params)
				.orderBy('dtfiled')
				.limit(10)
				.list()
	}

	def checkSyncCompleted(syncdata) {
		def param = [parentid: syncdata.objid, sync: 'SYNC', pending: 'PENDING']
		def unsyncitem = em_sync_item.select('objid')
							.where('parentid = :parentid AND state <> :sync', param)
							.first()
		return unsyncitem == null 
	}

	void cleanupFullySyncData(syncdata) {
    	def params = [parentid: syncdata.parentid, state: 'PENDING']
    	def forsync = em_sync_item.where('parentid = :parentid AND state = :state', params).first()
    	if (!forsync) {
    		deleteSyncData([objid: syncdata.parentid])
    	}
    }

	void deleteSyncData(syncdata) {
		em_sync_pending.find([objid: syncdata.objid]).delete()
		em_sync_forprocess.find([parentid: syncdata.objid]).delete()
		em_sync_item.find([parentid: syncdata.objid]).delete()
		em_sync.find([objid: syncdata.objid]).delete()
	}

    def getOrgId() {
    	if (env.ORGID) {
    		return env.ORGID
    	}
    	return em_org.find([root: 1]).first()?.objid
    }

    
}

